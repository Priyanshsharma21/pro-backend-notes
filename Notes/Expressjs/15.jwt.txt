
JWT (JSON Web Token) is a 
compact - JWT is a small
self-contained - JWT is complete package that contains all the necessary information within the token itself. It includes the header, payload, and signature, making it self-contained and independent.

token format that is commonly used for authentication and authorization in web applications. It consists of three parts: the header, the payload, and the signature.







!1. Header:
The header component of a JWT contains information about the token's type and signing algorithm.
It is a JSON object encoded in Base64Url format. The most commonly used algorithm is HMAC SHA256 or RSA, which is used to generate the signature.


{
  "alg": "HS256",
  "typ": "JWT"
}




!2. Payload:
The payload component of a JWT contains the claims or statements about the entity (user, application, etc.) and additional data. It is also a JSON object encoded in Base64Url format. There are three types of claims:

Registered Claims: These are predefined claims that provide useful information about the token. Some common registered claims include "iss" (issuer), "sub" (subject), "exp" (expiration time), and "iat" (issued at time).


Public Claims: These are custom claims defined by the creator of the JWT. They are not standardized but can be used to add application-specific information.


Private Claims: These are custom claims that are agreed upon by parties that use JWT for specific purposes and are neither registered nor public.


NOTE - Claims provide information about the entity or additional metadata associated with the token.



{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1622036800,
  "exp": 1622040400
}





!Signature:
The signature component of a JWT is generated by combining the encoded header, encoded payload, and a secret key using the specified algorithm (e.g., HMAC SHA256). The signature is used to verify the integrity of the token and ensure that it has not been tampered with. Only the server that possesses the secret key can generate a valid signature and verify the authenticity of the token.


HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secretKey
)


Ex - eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiAiMTIzNDU2Nzg5MCIsICJuYW1lIjogIkpvaG4gRG9lIiwgImlhdCI6IDE2MjIwMzY4MDAsICJleHAiOiAxNjIyMDQwNDAw




Once a JWT is generated, it can be included in the Authorization header of subsequent requests to authenticate the user. The server can validate the token by verifying the signature and checking the claims (expiration, issuer, etc.) to ensure the token is still valid.

JWTs are often used in token-based authentication systems, allowing users to authenticate once and receive a token that can be used for subsequent requests instead of sending credentials with every request. They are commonly used in stateless applications or microservices architectures.

It's important to note that JWTs are self-contained and should not contain sensitive information as the payload can be decoded (although not tampered) by anyone who possesses the token.



const jwt = require('jsonwebtoken');

! Example payload data
const payload = {
  userId: 123,
  username: 'john.doe',
  role: 'admin',
};

! Secret key used to sign the JWT
const secretKey = 'your-secret-key';

! Creating and signing a JWT
const token = jwt.sign(payload, secretKey);

console.log('JWT:', token);

! Verifying and decoding the JWT
try {
  const decoded = jwt.verify(token, secretKey);
  console.log('Decoded:', decoded);
} catch (error) {
  console.error('Invalid token:', error.message);
}